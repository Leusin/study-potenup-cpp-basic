# STL 문자열 / 문자 인코딩
*2025/07/16*
## 문자 인코딩

**문자(character)를 숫자(number)로 바꾸는 규칙**

컴퓨터는 결국 0과 1밖에 모르기 때문에 “가”, “A”, “♥” 이런 문자들을 이진수 코드로 바꿔서 저장한다. 그걸 정의한 게 바로 인코딩.

- **ASCII**: 영어 전용, 7비트(128문자) - 한글 없음
- **EUC-KR**: 옛날 한국 한글용 - 영어+한글만 됨. 유통기한 끝났음.
- **UTF:** 유니코드 - 세계 표준

인코딩 안 맞으면 **글자가 깨진다.** (  ← 이런 거나, A를 저장했는데, 열어보면 ¼ 같은 거)

따라서  "어떤 인코딩으로 저장했는지" 와  "어떤 인코딩으로 읽을지"를 반드시 맞춰야 됨.

## 유니코드(UTF-8, UTF-16, UTF-32)

모두 유니코드를 저장하는 방식인데, 크기(바이트 수)랑와 **속도/호환성**이 다르다.

### UTF-8

*Unocode Transformastion Format-8bit*

- **가변 길이**: 1~4바이트
    - 영어와 숫자: **1바이트**
    - 한글: **3바이트**
    - 이모지: **4바이트**
- 장점
    - 영어 위주 데이터에 압도적 효율
    - ASCII와 100% 호환
- 단점
    - 문자마다 바이트 수 달라서 문자 개수 세기나 탐색 느림

### UTF-16

*Unocode Transformastion Format-16bit*

- 기본 2바이트, 필요한 경우 4바이트
    - 대부분 문자(한글 포함): 2바이트
    - 특수 문자, 이모지: 4바이트 (Surrogate pair)
- 장점
    - 동아시아 문자(한중일) 처리 효율 Good
    - **언리얼 엔진**, **윈도우 API** 등에서 사용
- 단점
    - 바이트 불균일 (완전 고정은 아님)
    - UTF-8보단 호환성 떨어짐

### UTF-32

*Unocode Transformastion Format-32bit*

- **모든 문자 → 4바이트 고정**
    - 영어, 한글, 이모지 모두 4바이트

**장점**:

- 문자마다 사이즈 고정

**단점**:

- 메모리 비효율