## 경합 조건(Race Condition)

두 개 이상의 프로세스나 스레드가 공유 자원에 동시에 접근하고 변경할 때, 접근 순서에 따라 실행 결과가 달라지는 상황

- 공유 자원의 예: 변수, 파일 하드웨어

## 프로세스와 스레드

### 프로세스(Process)

- 운영체제로 부터 자원을 할당 받아 실행되는 독립적인 프로그램 단위
- 독립된 메모리 주소를 가지기 때문에, 다른 프로세서의 자원에 직접 할당할 수 없음
- 문맥 교환 발생 시, CPU 레저스터와 메모리 주소공간(페이지 테이블) 전체 교체 ← 비용 크고 오래 걸리는 편

### 스레드(Thread)

- 프로세스의 메모리 영역 중 정적 데이터, 힙, 코드를 공유하지만 각 스레드는 고유한 스택과 CPU 레지스터를 가짐
- **스레드 스케줄러**에 의해 다른 스레드가 실행될 때 문맥(CPU 레지스터)을 저장하고 복원해 각 스레드가 자신만의 실행 흐름을 이어가도록 함
- 문맥 교환 시 CPU 레지스터만 교체하고 공유 메모리는 바꾸지 않아도 됨 ← 프로세스 문맥 교환보다 효율적이고 빠름

# 락(lock)

- 경합 조건같은 문제를 해결하고, 데이터 일관성 유지를 위한 **동기화 매커니즘**
    - **상호 배제**(Mutual Exclusion): 공유 자원에 접근하는 구간(임계 영역, Critical Section)에 하나의 스레드/프로세스만 진입하도록 함
    - **원자성 보장**(Atomic Operation): 여러 작은 연산을 하나의 큰 연산으로 처리(ex. 읽기, 수정하기, 저장하기를 한 묶음으로)
- **협력적 락**(Advisory Lock): 락이 걸렸는지 확인하고 접근하지 않겠다 약속. 약속을 지킬지는 프로그램이 결정
- **강제적 락**(Mandatory Lock): 모든 접근 시도를 시스템 차원(운영체제)에서 막음

## 트랜잭션과 작업 크기

### 트랜잭션(Transaction)

데이터베이스에서 상태를 변경시키는 일련의 작업들을 하나의 논리적인 단위로 묶어 처리하는 것입니다.

### 작업 크기(Granularity)

- 락이 잠그고 있는 영역의 크기
- 작은 부분을 잠그면 ‘**세밀한 작업 크기**(fine-granularity)’, 더 큰 범위라면 ‘**성긴 작업 크기**(*거친 작업 크기*, coarse-grained)’

### 락 대기

- **스핀(spin,** *뺑뺑이***)**: 락을 얻을 때까지 반복적으로 확인 하는 방식
- **등록(register)/통지(notify)**: 락을 요청하는 쪽에서 등록하고 요청이 받아졌을 때 통지를 받음
- **블로킹(blocking)**: 락을 얻지 못했을 때 해당 스레드/프로세스를 일시중단(suspend)하는 방식
- **논블로킹(non-bloking)**: 락을 얻지 못했을 경우 다른 작업을 계속 진행하는 방식

### 교착상태

- 둘 이상의 프로세스나 스레드가 서로 가지고 있는 자원을 기다리며, 무한히 대기하는 상황
- 교착상태가 발생하기 위한 네 가지 조건
    1. **상호 배제 (Mutual Exclusion)**: 한 번에 하나의 프로세스만 자원을 사용
    2. **점유 및 대기 (Hold and Wait)**: 자원을 하나 이상 소유한 상태에서 다른 프로세스가 가진 자원을 추가로 요구하며 기다림
    3. **비선점 (No Preemption)**: 다른 프로세스가 사용 중인 자원을 강제로 뺏을 수 없어야 
    4. **순환 대기 (Circular Wait)**: 자원을 기다리는 관계가 원형을 이루어 서로 다음 차례를 기다림
- 해결 방안(선택을 잘 해야 한다.)
    1. 자원을 상호 배제하지 않고 공유할 수 있는 자원으로 만듦
    2. 여러 자원을 필요로 한다면 한꺼번에 자원 요구
    3. 선점형으로 바꿈
    4. 자원마다 우선순위 부여
